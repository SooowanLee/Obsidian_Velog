---
상태: 진행중
시작일: 2024-05-17
마감일: 2024-05-17
---
#### 기본인증
- 만료시간이 없다.
- 사용자 세부정보가 토큰에 저장되지 않는다.
- 디코딩이 쉽다. 

## **JWT(Json Web Token)**
>JWT는.(dot)을 기준으로 헤더(header), 내용(payload), 사인(signature)으로 이루어져 있다.
![](https://i.imgur.com/SxP6ZTb.png)

#### **헤더(header)**
> 토큰의 타입, 해싱 알고리즘 정보를 담는다. 그런 다음 이 JSON은 Base64 Url로 인코딩 되어 JWT의 첫 번째 부분을 구성합니다.

```null
{
    "typ": "JWT", //거의 고정
    "alg": "HS256"
}
```
### **내용(payload)**
> 토큰과 관련된 정보를 담는다. 단순 Base64로 인코딩 된 파트이기 때문에 누구나 디코딩하여 데이터를 볼 수 있다. Password 같은 민감한 정보는 담으면 안 된다.

**클레임**

- **정보의 한 ‘조각’을 클레임(claim)이라고 한다.**
- **key:value 한 쌍으로 이루어져 있다.**
- **엔티티(일반적으로 사용자) 및 추가 데이터에 대한 설명이다.**

### **Playload 전체적인 모습**

```null
{
    "iss":"test@gmail.com",     //등록된 클레임
    "iat":"2323232323",         //등록된 클레임
    "exp":"3434343434",         //등록된 클레임
    "https":"//test.com/jwt_claims/is_admin" :true, //공개 클레임
    "email":"test@gmail.com",    //비공개 클레임
    "hello":"안녕하세요!"         //비공개 클레임
}
```

**종류(등, 공, 비)**
- 등록된 클레임
- 공개 클레임
- 비공개 클레임

**등록된 클레임(registered claim)**
- 토큰에 대한 정보를 담는 데 사용한다. 필수는 아니지만 권장되는 미리 정의된 클레임 집합
- JWT가 압축되도록 되어 있으므로 클레임 이름은 3자로 정의된다.
- ex) iss(토큰 발급자), sub(토큰 제목), aud(토큰 대상자) 등 여러 가지가 있다.

```null
{
    "iss":"test@gmail.com",     //등록된 클레임
    "iat":"2323232323",         //등록된 클레임
    "exp":"3434343434",         //등록된 클레임
}
```

**[다른 등록된 클레임에 대해 궁금하신 분을 위한 자료]**

[https://datatracker.ietf.org/doc/html/rfc7519#section-4.1](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1)

**공개 클레임(public claim)**
- JWT를 사용하는 사람들이 원하는 대로 정의할 수 있다.
- **하지만**, **충돌을 방지하려면 충돌 방지 ‘네임스페이스를 포함하는 URI’로 정의해야 한다.**

```null
"https":"//test.com/jwt_claims/is_admin" :true, //공개 클레임
```

**비공개 클레임(private claim)**
- **사용에 동의한 당사자(보통 클라이언트 ↔ 서버) 간에 정보를 공유하기 위해 생성된 맞춤 클레임이다.**
- 등록되거나 공개된 클레임이 아니다. **이름**이 **중복**되어 **충돌**이 될 수 있으니 사용할 때에 **유의**해야 한다.

```null
{
  "sub": "1234567890",
  "name": "test lee",
  "admin": true
}
```

## **서명(signature)**
> 서명은 메시지가 도중에 변경되지 않았는지 확인하는 데 사용되며, 개인 키로 서명된 토큰의 경우 JWT의 보낸 사람이 누구인지 확인할 수도 있다.

### **서명 생성**
- **인코딩 된 헤더, 인코딩된 페이로드, 비밀, 헤더에 지정된 알고리즘을 가져와서 서명해야 합니다.**

**SHA256 알고리즘을 사용하려는 경우 서명은 다음과 같은 방식으로 생성된다.**

- **제일 마지막의 secret의 경우 사용자가 지정한 비밀 코드(너무 간단하지 않게 작성해야 한다.)**

```null
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

## 액세스 토큰과 리프레시 토큰

딱 봐도 어떤 역할을 할지 감이 온다. 매우 직관적인 네이밍이다.

- **엑세스 토큰** : 처음 API 호출 시 사용하는 토큰
- **리프레시 토큰** : 엑세스 토큰이 만료되었을 때 엑세스 토큰을 재발급 목적으로 사용하는 토큰

### 엑세스 토큰과 리프레시 토큰을 나눈 이유

만약, 엑세스 토큰의 유효기간이 하루라고 할 때, 중간에 **토큰**을 **탈취당하는** 일이 **발생**한다면

토큰의 특성상 **회수**를 **할 수 없**기 때문에 사용자의 **민감한 정보**에 마구 접근해도 **막을 수가 없**다.

이를 예방하기 위해 **액세스 토큰**의 **유효기간**은 **짧게** (약 1시간)

**리프레시 토큰**의 **유효기간**은 비교적 **길게**(약 2주) 설정한다.

이런 방식을 통해서 엑세스 토큰이 탈취를 당했더라고 만료 주기가 짧기 때문에 **피해를 줄일 수 있다**.

## 최종적인 JWT의 모습

> 서명된 토큰의 경우 변조로부터 보호되지만 누구나 읽을 수 있다. 암호화되지 않은 경우 JWT의 페이로드 또는 헤더 요소에 비밀 정보를 넣지 않고, 간단한 정보만 제공한다.

![](https://velog.velcdn.com/images/lsy9406/post/a19fb414-c818-49d4-8024-99e3699c30bc/image.png)